---
title: "DGE analysis of SLCs"
output: 
  html_document: 
    df_print: paged
---

```{r}
# 2024.3.24
#if (!requireNamespace("BiocManager", quietly = TRUE))
#    install.packages("BiocManager")
#BiocManager::install("biomaRt")

#library(biomaRt)

```

```{r}
library(tidyverse)
#library(stringr)
#library(dplyr)
library(limma)
library(edgeR)
library(ggplot2)
library(ggdendro)
library(pvclust)
library(gplots)
library(cluster)
library(igraph)
library(goseq)
library(treemap)
library(clusterProfiler)
library(org.Hs.eg.db)
library(RColorBrewer)
library(heatmap3)
library(pheatmap)
```
First we copy the [list of SLCs in mammalian genomes](https://esbl.nhlbi.nih.gov/Databases/SLC-list/) and convert gene IDs to ENSG IDs with tool on this [page](https://biit.cs.ut.ee/gprofiler/convert).Then we can select all SLCs in GTEx gene counts data file with `filter.py` in terminal.
```{bash, eval=FALSE}
python filter.py -f1 ../Input/gProfiler_hsapiens_12-11-2023_6-02-56\ AM.csv -f2 ../Input/bulk-gex_v8_rna-seq_GTEx_Analysis_2017-06-05_v8_RNASeQCv1.1.9_gene_reads.gct -o ../Input/GTEx_SLCs_gene_reads.gct
```

```{r}
tissue1 <- 'Breast'

# Load count data
#counts.data <- read_tsv("../Input/GTEx_SLCs_gene_reads.gct")

samp.anno.data <- read_tsv("../Input/GTEx_Analysis_v8_Annotations_SampleAttributesDS.txt")
subj.anno.ds.data <- read_tsv("../Input/GTEx_Analysis_v8_Annotations_SubjectPhenotypesDS.txt")
counts.data <- counts.data[,-1]

#counts.data.backup <- counts.data
counts.data <- counts.data.backup



select <- dplyr::select

# Retrieve the count data of 2 among so many various tissues to analyse. Subsequent analysis should include all the data
tiss1.sampid <- samp.anno.data %>%
  filter(SMTS==tissue1) %>% 
  select(SAMPID,SMTSD)

#tiss2.sampid <- samp.anno.data %>% 
#  filter(SMTS==tissue2) %>% 
#  select(SAMPID)

#counts.data <- counts.data.backup

#ids <- tiss1.sampid %>% 
#  bind_rows(tiss2.sampid) %>% 
#  add_row(SAMPID='Description') %>% 
#  pull() %>% 
#  paste(collapse="|")

ids <- tiss1.sampid %>% 
#  bind_rows(tiss2.sampid) %>% 
  add_row(SAMPID='Description') %>% 
  .$SAMPID


counts.data <- counts.data %>%
  select(any_of(ids))

missing_ids <- ids[!ids %in% colnames(counts.data)]

#counts.data <- counts.data %>% 
#  select(matches(ids))



# For our subsequent analyses we want to reduce the data set to only those genes with some expression. In this case we will discard genes with no reads in >= 50 samples
counts.data <- counts.data[rowSums(counts.data[,-1]==0)<50,]

genelist <- unique(counts.data$Description)

#cor.table <- cor(counts.data[,-1])
#cor.table %>% gplots::heatmap.2(dendrogram="row", trace = "none", col=viridis::viridis(25, begin=.25), margins=c(7,8))

# Create a tibble for edgeR description
#tiss1.sampid <- tiss1.sampid %>% 
#  mutate(TS=tissue1)

#tiss2.sampid <- tiss2.sampid %>% 
#  mutate(TS=tissue2)
```
Before we can normalize the data we need to be able to tell edgeR which groups the samples belong to. Here group refers to the distinct sample types (i.e. combinations of tissue, age, death circumstance)
```{r}
sample.description <- tiss1.sampid %>% 
#  bind_rows(tiss2.sampid) %>%
  mutate(SUBJID=str_extract(SAMPID, 'GTEX-.+(?=-.+-SM)')) %>%
  left_join(subj.anno.ds.data, by='SUBJID') %>% 
  mutate(group=paste(SMTSD, SEX, AGE, DTHHRDY, sep="_")) %>% # TS to SMTSD
  select(-SUBJID)

colnames(sample.description)[2] <- 'TS'

#sample.description <- sample.description %>%
#  mutate(SMTSD=factor(SMTSD,level = c("Brain - Frontal Cortex (BA9)","Brain - Cortex","Brain - Cerebellum","Brain - Cerebellar Hemisphere","Brain - Caudate (basal ganglia)","Brain - Nucleus accumbens (basal ganglia)","Brain - Putamen (basal ganglia)","Brain - Hypothalamus","Brain - Spinal cord (cervical c-1)","Brain - Hippocampus","Brain - Anterior cingulate cortex (BA24)","Brain - Substantia nigra","Brain - Amygdala")),
#         SEX=factor(SEX,levels = c(1,2)),
#         AGE=factor(AGE,levels = c("20-29","30-39","40-49","50-59","60-69","70-79")),
#         DTHHRDY=factor(DTHHRDY,levels = c(0,1,2,3,4)))

sample.description <- sample.description %>%
  mutate(
    TS = factor(TS, levels = unique(TS)),
    SEX = factor(SEX, levels = sort(unique(SEX))),  # numeric should be sorted
    AGE = factor(AGE, levels = c("20-29", "30-39", "40-49", "50-59", "60-69", "70-79")),
    DTHHRDY = factor(DTHHRDY, levels = sort(unique(DTHHRDY)))  # sort numerically
  )

sample.description
```
Calculate normalization factors by TMM method while RPKM is poorly behaved statistically, and plot multidimensional scaling plot of distances between gene expression profiles by logFC methods instead of bcv due to the large quantity of samples
```{r}
counts.matrix <- counts.data %>% select(-Description) %>% as.matrix()
rownames(counts.matrix) <- counts.data$Description

sample.description <- tibble(SAMPID=colnames(counts.matrix)) %>%
  left_join(sample.description, by = join_by(SAMPID))

dge.data <- DGEList(counts=counts.matrix, 
                    group=sample.description$group)
 
dge.data <- calcNormFactors(dge.data, method = "TMM")
dge.data$samples

# Make a plot of the Biological Coefficient of Variation of each sample

# Try to find out if sample can be divided by variables (i.e. TS, AGE, SEX)

#plotMDS(dge.data,method="logFC",pch=matched_pchs,bg=matched_bgs,col=matched_cols,
#        cex=1.4, dim.plot=c(3,2))

```

```{r}
# Assuming sample.description is your data frame
#plot_info <- sample.description %>%
#  mutate(
#    AGE = factor(AGE),
#    SEX = factor(SEX, levels = c(1, 2), labels = c("Male", "Female")),
#    TS = factor(TS)  # TS column is same as SMTSD
#  )

plot_info <- sample.description %>%
  mutate(
    SEX = factor(SEX, levels = c(1, 2), labels = c("Male", "Female")),
    TS = factor(TS),
    AGE = as.character(AGE), #When AGE is a factor and ifelse() is used, it doesn't handle factors gracefully
    AGE = ifelse(is.na(AGE), "Unknown", AGE),# Handle missing AGE
    AGE = factor(AGE, levels = c("20-29", "30-39", "40-49", "50-59", "60-69", "70-79", "Unknown"))
      )


# Define colors and shapes dynamically
#library(RColorBrewer)
#display.brewer.pal(12, "Set3")

#colors_age <- RColorBrewer::brewer.pal(n = length(unique(plot_info$AGE)), name = "Set1")
#colors_tissue <- RColorBrewer::brewer.pal(n = length(unique(plot_info$TS)), name = "Set3")

#colors_tissue <- RColorBrewer::brewer.pal(n = length(unique(plot_info$TS)), name = "Set3")
colors_tissue <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set3"))(length(unique(plot_info$SEX)))

# Assign colors and shapes
#plot_info <- plot_info %>%
#  mutate(
#    col = colors_tissue[TS],  # Tissue colors
#    bg = colors_age[AGE],     # Age background colors
#    pch = ifelse(SEX == "Male", 21, 24)  # Sex shapes
#  )

#plot_info <- plot_info %>%
#  mutate(
#    bg = colors_tissue[TS],  # Tissue background colors
#    pch = ifelse(SEX == "Male", 21, 24)  # Sex shapes
#  )

plot_info <- plot_info %>%
  mutate(
    bg = colors_tissue[SEX], # Tissue colors
  )


matched_bgs <- plot_info$bg[match(colnames(dge.data), plot_info$SAMPID)]
#matched_pchs <- plot_info$pch[match(colnames(dge.data), plot_info$SAMPID)]
#matched_cols <- plot_info$col[match(colnames(dge.data), plot_info$SAMPID)]


# Increase the right margin to make space for the legend
par(mar=c(5, 4, 4, 2) + 0.1)  # Default is c(5, 4, 4, 2) + 0.1



#plotMDS(dge.data,method="logFC",pch=matched_pchs,bg=matched_bgs,col=matched_cols,
#        cex=1.4, dim.plot=c(1,2))

plotMDS(dge.data,method="BCV",pch=21,bg=matched_bgs,cex=1.4, 
        dim.plot=c(1,2))
 
# Adding a legend for Age outside the bottom of the plot
#legend("topright", inset=c(-0.2, 0.2), title="Age", legend=levels(plot_info$AGE), fill=unique(plot_info$bg), cex=0.8, y.intersp=0.7, xpd=TRUE)
# Adding a legend for Sex outside the top left of the plot
#legend("topright", inset=c(-0.2, 0), title="Sex", legend=levels(plot_info$SEX), pch=unique(plot_info$pch), cex=0.6, y.intersp=0.7, xpd=TRUE)
# Adding a legend for Tissue outside the top right of the plot
legend("bottomleft", title="Sex", legend=levels(plot_info$SEX), fill=unique(plot_info$bg), pch=21, cex=0.6, y.intersp=0.7, border=unique(plot_info$bg))

legend("bottomright", inset=c(-0.2, 0), title="Sex", legend=levels(plot_info$SEX), fill=unique(plot_info$bg), pch=21, cex=0.6, y.intersp=0.7, border=unique(plot_info$bg), xpd=TRUE)
```

```{r,eval=FALSE}
# Assuming sample.description is your data frame
plot_info <- sample.description %>%
  mutate(
    AGE = factor(AGE),
    SEX = factor(SEX, levels = c(1, 2), labels = c("Male", "Female")),
    TS = factor(TS)  # TS column is same as SMTSD
  )

# Define colors and shapes dynamically
#library(RColorBrewer)
#display.brewer.pal(12, "Set3")

#colors_age <- RColorBrewer::brewer.pal(n = length(unique(plot_info$AGE)), name = "Set1")
#colors_tissue <- RColorBrewer::brewer.pal(n = length(unique(plot_info$TS)), name = "Set3")

#colors_age <- RColorBrewer::brewer.pal(n = length(unique(plot_info$AGE)), name = "Set3")
colors_age <- colorRampPalette(RColorBrewer::brewer.pal(9, "Set3"))(length(unique(plot_info$AGE)))


# Assign colors and shapes
#plot_info <- plot_info %>%
#  mutate(
#    col = colors_tissue[TS],  # Tissue colors
#    bg = colors_age[AGE],     # Age background colors
#    pch = ifelse(SEX == "Male", 21, 24)  # Sex shapes
#  )

plot_info <- plot_info %>%
  mutate(
    bg = colors_age[AGE],  # Tissue background colors
    pch = ifelse(SEX == "Male", 21, 24)  # Sex shapes
  )


matched_bgs <- plot_info$bg[match(colnames(dge.data), plot_info$SAMPID)]
matched_pchs <- plot_info$pch[match(colnames(dge.data), plot_info$SAMPID)]
#matched_cols <- plot_info$col[match(colnames(dge.data), plot_info$SAMPID)]


# Increase the right margin to make space for the legend
par(mar=c(5, 4, 4, 8) + 0.1)  # Default is c(5, 4, 4, 2) + 0.1



#plotMDS(dge.data,method="logFC",pch=matched_pchs,bg=matched_bgs,col=matched_cols,
#        cex=1.4, dim.plot=c(1,2))

plotMDS(dge.data,method="logFC",pch=matched_pchs,bg=matched_bgs,cex=1.4, 
        dim.plot=c(1,2))
 
# Adding a legend for Age outside the bottom of the plot
#legend("topright", inset=c(-0.2, 0.2), title="Age", legend=levels(plot_info$AGE), fill=unique(plot_info$bg), cex=0.8, y.intersp=0.7, xpd=TRUE)
# Adding a legend for Sex outside the top left of the plot
legend("topright", inset=c(-0.2, 0), title="Sex", legend=levels(plot_info$SEX), pch=unique(plot_info$pch), cex=0.8, y.intersp=0.7, xpd=TRUE)
# Adding a legend for Tissue outside the top right of the plot
legend("bottomright", inset=c(-0.2, 0), title="Age", legend=levels(plot_info$AGE), fill=unique(plot_info$bg), pch=21, cex=0.8, y.intersp=0.7, border=unique(plot_info$bg), xpd=TRUE)
```

We can see samples are well divided into 2 clusters by tissue. This plot could convince us of the correctness of the experiment and data.
Randomly select 6 samples and plot them to check the effect of normalization
```{r}
# Filter out genes with low mean normalized counts (no need to do it as there's
# no gene could be filterd out here)
#avg_log_cpm <- rowMeans(cpm(dge.data, log=TRUE))
#min_log_cpm <- 0.5  # For example, log2 CPM of 0.5
#keep <- avg_log_cpm > min_log_cpm
#counts_filtered_final <- counts.matrix[keep, ]

counts.data.normal <- cpm(dge.data) 

# or log2 transformed:
counts.data.normal.log <- cpm(dge.data,log = TRUE)

# Assuming the first column might be non-numeric and should be excluded from the operation
counts.data[,-1] <- sapply(counts.data[,-1], function(x) as.numeric(as.character(x)))

# Check if there are any NAs introduced by incorrect conversions
sum(is.na(counts.data))

counts.data.log <- log2(counts.data[,-1] + 1)

counts.data.log.pvt <- counts.data.log

counts.data.log.pvt <- counts.data.log.pvt %>% 
  pivot_longer(colnames(counts.data.log.pvt), names_to="sample", values_to="value")

counts.data.log.pvt <- sample.description %>% 
  select(SAMPID, group) %>% 
  right_join(counts.data.log.pvt, by=join_by(SAMPID==sample))

counts.data.log.pvt %>% ggplot(aes(x=group, y=value)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 70))

counts.data.normal.log.pvt <- as.data.frame(counts.data.normal.log)
  

counts.data.normal.log.pvt <- counts.data.normal.log.pvt %>% 
  pivot_longer(colnames(counts.data.normal.log.pvt), names_to="sample", values_to="value")

counts.data.normal.log.pvt <- sample.description %>% 
  select(SAMPID, group) %>% 
  right_join(counts.data.normal.log.pvt, by=join_by(SAMPID==sample))

counts.data.normal.log.pvt %>% ggplot(aes(x=group, y=value)) +
  geom_boxplot() +
  theme(axis.text.x = element_text(angle = 70))
```

```{r}
# Now calculate dispersion factors
design <- model.matrix(~SEX,data = sample.description)
rownames(design) <- sample.description$SAMPID

# First the overall dispersion
dge.data <- estimateGLMCommonDisp(dge.data,design,verbose = TRUE)

# Then a trended dispersion based on count level
dge.data <- estimateGLMTrendedDisp(dge.data,design)

# And lastly we calculate the gene-wise dispersion, using the prior estimates to 
#"squeeze" the dispersion towards the common dispersion.
dge.data <- estimateGLMTagwiseDisp(dge.data,design)
```

```{r}
# Draw dispersion plot
plotBCV(dge.data)
```

```{r}
# Find genes that expressed differently in these 2 tissues
fit <- glmFit(dge.data, design)

ts.lrt <- glmLRT(fit,coef="SEX2")

# label genes with a FDR < 0.05 and a fold change > 1.5 and draw a volcano plot
results <- topTags(ts.lrt, n=Inf)$table
results$significant <- results$FDR < 0.05 & abs(results$logFC) > log2(1.2)
results$PValue <- pmax(results$PValue, 1e-300)  # replace exact 0s with a very small number

results$SignificanceLabel <- ifelse(results$significant, "Significant", "Not Significant")

ggplot(results, aes(x = logFC, y = -log10(PValue), col=significant)) +
  geom_point(alpha = 0.5) +
  geom_vline(xintercept = c(-log2(1.2),log2(1.2)), linetype="dashed",color="blue") +  # LogFC lines
  geom_hline(yintercept = -log10(0.05),linetype = "dashed",color = "blue") +  # FDR lin
  theme_minimal() +
  labs(x="Log2 Fold Change", y="-Log10 Adjusted P-value", title = "Volcano Plot")
# Summarize the number of differentially expressed genes
summary(decideTestsDGE(ts.lrt,p.value=0.05,lfc=log2(1.2)))

## Go enrichment analysis left to do here

## Get DGEs (Tissue as variable)
DEgenes <- topTags(ts.lrt,n = Inf,p.value = 0.05)$table
DEgenes <- DEgenes[abs(DEgenes$logFC)>log2(1.2),]
```



```{r}
## As Most of the simplest clustering assumes data to be from a normal 
##distribution. we need to transformed the RNAseq data to be normally 
##distributed

v <- voom(counts.matrix, design, plot=TRUE)
voom_E <- as.data.frame(v$E) %>% 
  rownames_to_column(var = "GeneID")

voom_Et <- voom_E %>%
  t() %>% 
  as.data.frame() %>% 
  rownames_to_column(var = "SAMPID") %>% 
  left_join(sample.description,by="SAMPID")

colnames(voom_Et) <- c("SAMPID",voom_Et[1,2:(ncol(voom_Et)-5)],1,2,3,4,"group")
voom_Et <- voom_Et[-1,-(ncol(voom_Et)-4):-(ncol(voom_Et)-1)] %>% 
  mutate(across(c(2:(ncol(voom_Et)-5)), as.numeric))

#voom_E

mean_vals <- voom_Et %>%
  group_by(group) %>%
  summarise(across(where(is.numeric), ~mean(., trim=0, na.rm=TRUE)))
 
mean_vals_t <- mean_vals %>% 
  t()
colnames(mean_vals_t) <- mean_vals_t[1,]

mean_vals_t <- mean_vals_t[-1,] %>% 
  as.data.frame() %>% 
  mutate(across(c(1:ncol(mean_vals_t)), ~as.numeric(.)))

mean_vals_t

mean_vals_t <- mean_vals_t[rownames(DEgenes),]

E_matrix <- mean_vals_t %>%
  as.matrix() %>% 
  scale() # scale and center the data so that each gene has a mean of 0 and a standard deviation of 1. This prevents genes with high expression from having an undue influence on our results



E_matrix <- E_matrix %>%
  t() %>% 
  scale() %>% 
  t()

gene_hclust_row <- E_matrix %>% dist() %>% hclust()
ggdendrogram(gene_hclust_row)

gene_hclust_col <- E_matrix %>% t()  %>% dist() %>% hclust()
ggdendrogram(gene_hclust_col)

#set.seed(12456) #This ensure that we will have consistent results with one another

#fit <- pvclust(E_matrix, method.hclust = "ward.D", method.dist = "euclidean", nboot = 100)

#plot(fit, print.num=FALSE) # dendogram with p-values



col_bar <- data.frame(Gender=factor(c(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2),levels=c(1,2), labels=c("Male", "Female")),row.names=colnames(E_matrix))

row_bar <- DEgenes %>% 
  mutate(Expression_Change=ifelse(logFC>=0,'Upregulated','Downregulated')) %>% 
  select(Expression_Change) %>% 
  mutate(Expression_Change=factor(Expression_Change, levels = unique(Expression_Change)))



pheatmap(E_matrix, color=cols, annotation_col = col_bar, annotation_row = row_bar)

cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)

col_bar <- brewer.pal(3, "Set1")[col_bar$Gender]
row_bar <- brewer.pal(2, "Set2")[row_bar$Expression_Change]

heatmap.2(E_matrix, Rowv = as.dendrogram(gene_hclust_row), Colv = as.dendrogram(gene_hclust_col), density.info="none", 
          trace="none", margins = c(20,10), col=rev(cols), key.title="Row Z-score", ColSideColors=col_bar, RowSideColors = row_bar)
```


```{r}
# K-means section

## get principle components
prcomp_counts <- prcomp(E_matrix) 
scores <- as.data.frame(prcomp_counts$x)[,c(1,2)]

## Get appropriate cluster number
#set.seed(125)
gap <- clusGap(E_matrix, FUN=kmeans, iter.max=10000, K.max=20, B=100)

plot(gap, main = "Gap Statistic")

with(gap, maxSE(Tab[,"gap"], Tab[,"SE.sim"], method="firstSEmax"))

# We now try 5 clusters
set.seed(25)
fit <- kmeans(E_matrix, 5)
clus <- as.data.frame(fit$cluster)
names(clus) <- paste("cluster")

plotting <- merge(clus, scores, by = "row.names")
plotting$cluster <- as.factor(plotting$cluster)

# plot of observations
ggplot(data = plotting, aes(x = PC1, y = PC2, label = Row.names, color = cluster)) +
  geom_hline(yintercept = 0, colour = "gray65") +
  geom_vline(xintercept = 0, colour = "gray65") +
  geom_point(alpha = 0.8, size = 2, stat = "identity") 
```

```{r}
clus <- cbind(clus, E_matrix) %>% # add cluster labels to gene expression matrix
  mutate(gene_index=1:nrow(clus)) # would be better to bring in gene names but OK for now.

clus <- clus %>% 
  pivot_longer(c(-cluster, -gene_index), names_to = "sample_ID", values_to = "expression") %>% # get ready for plotting
  mutate("sample_group" = str_remove(sample_ID, "(_[0134]|NA)$"))

clus_summary <- clus %>% # average across replicates
  group_by(gene_index, cluster, sample_group) %>%
  summarize(expression = mean(expression))

clus_summary %>% ggplot(aes(x=sample_group, y=expression, group=gene_index)) + # plot it
  geom_line(alpha=.15) +
  facet_wrap(~cluster, ncol=3) +
  coord_fixed(ratio=1) +
  theme(axis.text.x = element_text(angle = 90, size = 7, hjust = 1, vjust = 0))
```
```{r}
#  Co-Expression

voom_E_ts <- voom_E %>%
  filter(GeneID %in% rownames(DEgenes))

## Turn to matrix
E_matrix_ts <- voom_E_ts %>%
  as.data.frame() %>%
  column_to_rownames("GeneID") %>%
  as.matrix()

## Calculate mutual ranks
E_matrix_cor <- cor(t(E_matrix_ts))
diag(E_matrix_cor) <- 0
E_matrix_rank <- apply(E_matrix_cor,2,function(x) rank(-abs(x)))
E_matrix_MR <- sqrt(E_matrix_rank * t(E_matrix_rank))

genes_adj_MR4 <- E_matrix_MR <= 4
diag(genes_adj_MR4) <- 0

genes_adj_MR10 <- E_matrix_MR <= 10
diag(genes_adj_MR10) <- 0

## Plot our networks using different thresholds for connectivity
gene_graphMR4 <- graph.adjacency(genes_adj_MR4, mode = "undirected") #convert adjacency to graph
compsMR4 <- clusters(gene_graphMR4)$membership                        #define gene cluster membership
colbar <- rainbow(max(compsMR4)+1)                                   #define colors
V(gene_graphMR4)$color <- colbar[compsMR4+1]                          #assign colors to nodes
plot(gene_graphMR4, layout = layout_with_fr, vertex.size = 4, vertex.label = NA, main="MR 4")
  
gene_graphMR10 <- graph.adjacency(genes_adj_MR10, mode = "undirected") #convert adjacency to graph
compsMR10 <- clusters(gene_graphMR10)$membership                        #define gene cluster membership
colbar <- rainbow(max(compsMR10)+1)                                   #define colors
V(gene_graphMR10)$color <- colbar[compsMR10+1]                          #assign colors to nodes
plot(gene_graphMR10, layout = layout_with_fr, vertex.size = 4, vertex.label = NA, main="MR 10")
```

```{r, include=FALSE, eval=FALSE}
E_matrix_5 <- E_matrix_ts[11:15,]
E_matrix_5_cor <- cor(t(E_matrix_5))

diag(E_matrix_5_cor) <- 0


E_matrix_5_rank <- apply(E_matrix_5_cor,2,function(x) rank(-abs(x)))
E_matrix_5_rank

E_matrix_5_MR <- sqrt(E_matrix_5_rank * t(E_matrix_5_rank))
E_matrix_5_MR %>% round(3)

genes_adj_MR2 <- E_matrix_5_MR <= 2
diag(genes_adj_MR2) <- 0
genes_adj_MR2
```

```{r}
# Graph stats for network comparison
graph.density(gene_graphMR4)
average.path.length(gene_graphMR4)

graph.density(gene_graphMR10)
average.path.length(gene_graphMR10)
```
The increase of average path length can be caused by the dramatic increase of number of dots that been connected when the threshold grows from 4 to 10. These new connected dots are far away from each other compare to those that has already been connected when MR is 4. This may imply that MR4 is better than MR10 because those loosely connected genes suggest nothing regarding biological connection.

```{r}
# The most central genes
## Calculate degree centrality
MR4_DC <- colSums(genes_adj_MR4) %>%
  sort(decreasing = TRUE) %>%
  tibble(GeneID=names(.), degree=.)

MR10_DC <- colSums(genes_adj_MR10) %>%
  sort(decreasing = TRUE) %>%
  tibble(GeneID=names(.), degree=.)
```

```{r}
## Download annotations
# Load necessary libraries
#library(biomaRt)

# Select the human dataset
#mart <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

#attributes <- listAttributes(mart)

# Get annotations for your genes
# Note: 'GeneID' could be replaced by 'hgnc_symbol' or other attributes if you are using gene symbols or other identifiers
#go.terms <- getBM(attributes = c('hgnc_symbol', 'name_1006', 'namespace_1003'),
#                     filters = 'hgnc_symbol',
#                     values = all.genes,
#                     mart = mart)

#write.csv(go.terms,"../Input/go_domains.csv")

#go.domains <- getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'namespace_1003'),
#                     filters = 'hgnc_symbol',
#                     values = all.genes,
#                     mart = mart)
#write.csv(go.domains,"../Output/go_domains.csv")

#gene.lengths <- getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'transcript_length'),
#                     filters = 'hgnc_symbol',
#                     values = counts.data$Description,
#                     mart = mart)

#annotations <- getBM(attributes = c('ensembl_gene_id', 'hgnc_symbol', 'mim_gene_description'),
#                     filters = 'hgnc_symbol',
#                     values = genelist,
#                     mart = mart)

#write.csv(annotations,paste("../Output/", colnames(annotations)[3], ".csv", sep=""))

annotations <- read_csv("../Output/interpro_description.csv")

annotations <- na.omit(annotations) %>% 
  .[,2:4] %>% 
  group_by(ensembl_gene_id, hgnc_symbol) %>%
  summarise(
    interpro_description = paste("\"",interpro_description,"\"",collapse = ", "),
    .groups = 'drop'  # This option removes grouping after summarise
  )

MR4_DC <- merge(MR4_DC, annotations, by.x = "GeneID", by.y = "hgnc_symbol", all.x = TRUE)

MR4_DC <- MR4_DC[order(-MR4_DC$degree),]

MR10_DC <- merge(MR10_DC, annotations, by.x = "GeneID", by.y = "hgnc_symbol", all.x = TRUE)

MR10_DC <- MR10_DC[order(-MR10_DC$degree),]

head(MR4_DC,20)
head(MR10_DC,20)

gene_graphMR10 %>%
  betweenness() %>%
  sort(decreasing=TRUE) %>%
  head(20)

gene_graphMR4 %>%
  betweenness() %>%
  sort(decreasing=TRUE) %>%
  head(20)
```

```{r}
all.genes <- genelist
go.terms <- read_csv("../Input/go_terms.csv")
head(go.terms)
colnames(go.terms) <- c("GeneID","GO")
head(go.terms)

go.domains <- read_csv("../Input/go_domains.csv")
colnames(go.domains)[3:4] <- c("category","GO_domains")

go.domains <- na.omit(go.domains) %>% 
  .[,3:4] %>% 
  group_by(category,GO_domains) %>%
  summarise(.groups = 'drop')

gene.lengths <- read_csv("../Input/gene_lengths.csv")
head(gene.lengths)
colnames(gene.lengths) <- c("GeneID","Length")
head(gene.lengths)

gene.lengths.vector <- gene.lengths$Length[gene.lengths$GeneID %in% all.genes]
names(gene.lengths.vector) <- gene.lengths$GeneID[gene.lengths$GeneID %in% all.genes]
head(gene.lengths.vector)

#all.genes <- genes
#genes <- all.genes
all.genes <- tibble(unique(all.genes))
colnames(all.genes) <- c("GeneID")

#Do the reverse to make sure everything matches up (it seems that we don't have length info for some genes?)
expressed.genes.match <- all.genes[all.genes$GeneID %in% names(gene.lengths.vector),]

go.list <- strsplit(go.terms$GO,split=",")
names(go.list) <- go.terms$GeneID
head(go.list)

#for each gene in expressed gene, return FALSE if it is not in DEgenes and TRUE if it is.
DE.ts <- expressed.genes.match$GeneID %in% rownames(DEgenes)
names(DE.ts) <- expressed.genes.match$GeneID
head(DE.ts)

DE.ts <- as.numeric(DE.ts) #convert to 0s and 1s
head(DE.ts)
sum(DE.ts) # number of DE genes


```




```{r}
# Example genelist and DEgenes data
# genelist <- counts.data$Description  # Already existing full gene list
# DEgenes <- ...  # Assuming DEgenes is your list of differentially expressed genes

# Convert gene symbols to Entrez IDs for the full gene list
all_entrez_ids <- unlist(mapIds(org.Hs.eg.db,
                                keys = genelist,
                                column = "ENTREZID",
                                keytype = "SYMBOL",
                                multiVals = "first"))

# Filter to remove NAs
all_entrez_ids <- all_entrez_ids[!is.na(all_entrez_ids)]

# Convert DE gene symbols to Entrez IDs
sig_entrez_ids <- unlist(mapIds(org.Hs.eg.db,
                                keys = rownames(DEgenes),  # assuming rownames are gene symbols
                                column = "ENTREZID",
                                keytype = "SYMBOL",
                                multiVals = "first"))

# Filter to remove NAs
sig_entrez_ids <- sig_entrez_ids[!is.na(sig_entrez_ids)]

ego <- enrichGO(gene          = sig_entrez_ids,
                universe      = all_entrez_ids,
                OrgDb         = org.Hs.eg.db,
                keyType       = "ENTREZID",
                ont           = "ALL",  # Biological Process; use "CC" for Cellular Component, "MF" for Molecular Function
                pAdjustMethod = "BH",
                qvalueCutoff  = 1,
                pvalueCutoff = 0.1,
                readable      = TRUE)  # Convert ENTREZ IDs back to gene symbols for readability



dotplot(ego) + ggplot2::ggtitle("GO Enrichment Analysis")

barplot(ego,
        x="Count",
        color="p.adjust",
        split="ONTOLOGY") +
  facet_grid(ONTOLOGY~., scale='free')

```



```{r}
# Convert Your Complete Gene List to Entrez IDs
# Assuming genelist contains all expressed gene symbols
all_entrez_ids <- unlist(mapIds(org.Hs.eg.db,
                                keys = genelist,
                                column = "ENTREZID",
                                keytype = "SYMBOL",
                                multiVals = "first"))
all_entrez_ids <- all_entrez_ids[!is.na(all_entrez_ids)]  # Remove NAs

# Convert Significantly Differentially Expressed Gene Symbols to Entrez IDs
sig_genes <- rownames(DEgenes)  # Assuming these are your significantly differentially expressed genes
sig_entrez_ids <- unlist(mapIds(org.Hs.eg.db,
                                keys = sig_genes,
                                column = "ENTREZID",
                                keytype = "SYMBOL",
                                multiVals = "first"))
sig_entrez_ids <- sig_entrez_ids[!is.na(sig_entrez_ids)]  # Filter out NAs


# Perform KEGG enrichment analysis
kegg_result <- enrichKEGG(gene = sig_entrez_ids,
                          universe = all_entrez_ids,
                          organism = 'hsa',  # Assuming human genes
                          keyType = 'ncbi-geneid',
                          qvalueCutoff  = 1,
                          pvalueCutoff = 1)

# Viewing the first few results
head(kegg_result)

# Optional: Visualize the results
dotplot(kegg_result) + ggplot2::theme_minimal()
```
